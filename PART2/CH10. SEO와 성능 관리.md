> 💡 **CHAPTER 10 SEO와 성능 관리**
>
> - SSR, SSG, CSR 중 애플리케이션에 가장 잘 맞는 렌더링 전략 선택 방법
> - 애플리케이션의 성능에 영향을 미치는 일반적인 원인
> - Vercel Analytics 모듈 사용법
> - SEO 친화적인 웹 애플리케이션 개발에 도움이 되는 도구

Next.js는 성능과 SEO 점수를 향상시키기 위해 여러 번 개선되었지만 SEO점수나 성능에 나쁜 영향을 미칠 수 있는 잠재적인 문제가 여전히 웹 애플리케이션에 있을 수 있다.

# 10.1 SEO와 성능

- 리액트, 앵귤러, 뷰 그 외에 많은 프레임워크가 복잡한 UI를 훨씬 쉽고 간단하게 구현할 수 있는 환경을 제공해줌 → 웹 스파이더나 봇과 같이 검색 엔진으로 웹 사이트 검색 결과와 색인 정보를 수집하는 도구는 원활하게 작동하기 어려워짐
- Next.js는 부분적으로 어떤 페이지는 정적으로 만들고 서버에서 렌더링할지와 어떤 컴포넌트를 클라이언트에서만 렌더링할지를 정할 수 있다.

# 10.2 SEO와 성능 관점에서의 렌더링 전략

Next.js를 사용할 때의 이점은 장단점과 타협할 필요가 없다는 것이다. 그저 웹 애플리케이션의 각 페이지에 알맞은 렌더링 전략을 고르기만 하면 된다.

### 클라이언트 사이드 렌더링(CSR)

- 애플리케이션은 하나의 자바스크립트 번들 형태로 배포 → 웹 브라우저가 이 자바스크립트 번들 전체를 다운로드한 뒤 코드를 실행해서 HTML 콘텐츠를 동적으로 만들 것
- 성능이 뛰어나고 매우 동적인 콘텐츠를 만들 수 있으나 SEO 점수가 낮고 보안상 문제가 있을 수 있다.

### 서버 사이드 렌더링(SSR)

- SEO유리한 콘텐츠들은 전부 서버가 렌더링하고 나머지는 클라이언트에서 렌더링하도록 만들 수 있다. 서버가 데이터를 불러오고 검사하기 때문에 민감함 API 호출 등을 숨길 수 있어서 보안 측면에도 좀 더 안전함
- 서버가 렌더링하면 서버를 준비하고 유지 및 보수해야하며 필요하다면 확장도 해야 함. 트래픽이 늘어날수록 서버는 느려지고 비용이 증가하며 유지 보수도 어려워짐

### 정적 사이트 재생성(SSG)

- SEO 점수와 성능 면에서 가장 뛰어날 수 있지만 보안상 문제가 있으며 동적 콘텐츠 생성이 어려움

![image](https://github.com/Hayeong8957/NextJS_BookStudy/assets/70371342/761f0b3c-9c4c-493b-93fa-c75041d03ace)

### 실제 웹 사이트를 통해 살펴본 렌더링 전략의 선택 이유

사진 서비스를 제공하는 웹 사이트를 만든다고 가정

[ 기능 ]

- 사진을 업로드하고 플랫폼의 다른 사용자로부터 피드백과 점수를 얻을 수 있다.
- 사용자가 로그인하면 홈페이지에 팔로우하는 다른 사용자들의 사진 목록이 표시된다.
- 사진을 클릭하면 사진 세부 정보와 함께 답글, 피드백, 사진에 얽힌 이야기 등을 읽을 수 있는 상세페이지가 보여짐

[ 렌더링 전략 ]

- 이미지 표시할 영역이 포함된 홈 페이지를 정적으로 렌더링하고 이미지는 리액트 하이드레이션을 통해 클라이언트에서 가져옴 → 홈 페이지에서는 사용자가 로그인했는지, 팔로우하는 사용자가 있는지 여부 등을 통해 이미지를 불러오고 동적으로 표시함
- 서버가 페이지를 렌더링함. 세션 큐키를 사용해서 사용자가 로그인했는지 파악한 다음 서버가 이미지를 불러와서 페이지를 렌더링하고 클라이언트로 보냄
- 사진 목록 생성하고 전송하는 API가 충분히 빠르고 이미지가 잘 최적화된다면 전체 사진 목록을 서버가 렌더링해도 괜찮음 → 그렇지 않다면 클라이언트 측에서 API 호출하여 사진 목록이 클라이언트에 도착하기 전까지 사용자에게 표시될 콘텐츠 페이지를 예쁘게 만들어서 제공하는 것이 더 유리
- 전체 페이지는 정적으로 만들면서 리액트 하이드레이션을 통해 API 호출 → SSG, CSR

사진 세부 정보 페이지

- 사진 설명, 태그, 답글 및 피드백 표시 → SEO 중요 → SSG와 SSR 둘 중 하나

### 동적 페이지에 SSG를 사용할 때 장단점

- 빌드 시점에 만든 정적페이지 경우 각 요청별로 서버가 다시 렌더링할 필요 없음 → 서버 부하 줄고 인프라 비용 감소
- 정적 페이지 생성 이후 사진 업로드한 사용자가 정적 콘텐츠의 일부를 수정하고 싶을 수도 있다. 언제 정적 페이지를 다시 생성해야 하는지 알 수 있음 → 정적 콘텐츠가 변경될 경우 서버가 정적 증분 재생성을 주기적으로 실행해서 정적 페이지를 다시 만들도록 할 수 있음
- 페이지 성능이 가장 뛰어남
- SEO 점수에 크게 영향을 주지 않는 답글이나 좋아요 수 등의 동적 콘텐츠는 클라이언트가 데이터를 불러와서 렌더링할 수 있음
- 사용자가 새로운 사진을 업로드한 경우 다음 빌드까지 기다려야만 웹 사이트에 해당 사진을 표시할 수 있는 것은 아님 → getStaticPaths 함수가 반환하는 객체 내에 fallback: true 속성을 추가하면 Next.js가 페이지 요청 시점에 새로운 페이지를 정적으로 만듦

SSG를 사용할 때는 동적 라우트 사용 여부를 반드시 염두에 두어야 함. 향후 웹 사이트가 얼마나 많은 동적 페이지를 지원할 것인지, 이런 웹 페이지를 빌드할 떄 어느 정도의 시간이 소요되는지를 항상 고민

### 동적 페이지에 SSR을 사용할 때 장단점

- 사용자가 페이지 콘텐츠를 변경하는 경우 증분 정적 재생성을 통해 해당 콘텐츠가 웹 페이지에 반영될 때까지 기다릴 필요가 없음 → 사진과 관련된 새로운 정보를 추가하거나 변경하는 즉시 웹 페이지가 해당 수정사항을 반영하고 표시
- 요청한 페이지를 그때 렌더링하기에 페이지 빌드 시간이 짧아지며 배포 소요 시간 단축
- 사진 서비스 웹사이트 경우 수천 장의 사진이 업로드 될 것이며 각 사진별로 세부 정보 페이지가 제공될 것 → SSR이 적합

### 프라이빗 라우트

- 아무나 접근할 수 없는 페이지를 뜻함 , 로그인한 사용자만 접근 가능한 페이지 같은 거
- 보안이 가장 중요 → 보안을 지키기 위해 성능 저하를 감수하기도 함
- 정적으로 빠르게 빌드하고 클라이언트 측에서 필요한 API 호출을 처리하도록 만들 수도 있다. 하지만 클라이언트 측에서 API 호출을 제대로 다루지 못하면 민감한 개인 정보나 비밀 데이터가 노출될 수 있다.
- SSR을 사용하여 익명의 사용자가 접근했는지 탐지하고 권한이 없는 사용자는 다른 페이지로 리다이렉트할 것임.
- 페이지에 접근한 사용자가 로그인한 상태라면 getServerSideProps 함수를 통해 필요한 모든 데이터를 백엔드에서 미리 불러온 다음 클라이언트로 더 안전하게 전송할 수 있음

### 선택한 렌더링 전략 정리

- 홈페이지

커스텀 이미지 목록 제외한 모든 페이지 정적 생성

- 사진 세부 정보 페이지

SSR을 사용하면 페이지의 SEO점수를 향상시킬 수 있으며, 특히 사진이 아주 많은 경우 사진 세부 정보 페이지를 처리하기 위해 필요한 웹 사이트 자원을 효율적으로 확장할 수 있다.

인기 있는 페이지들은 SSG를 사용해 빌드 시점에 미리 정적 페이지로 만들어두고, 그렇지 않은 페이지 경우 실행 시간 동안 요청이 있을 때 정적 페이지를 만드는 방식을 사용할 수 있다.

- 프라이빗 페이지

SSR 사용, 서버가 필요한 프라이빗 데이터를 모두 불러와서 처리한 후 클라이언트에 제공하기 때문에 프론트엔드에서 API 호출을 숨길 수 있다.

# 10.3 SEO 다루기

### SEO 친화적인 라우팅 구조를 만든다

url은 사용자 친화적이어야 하며 특정 로직에 따라 구성되어야 함. 페이지의 url만 가지고도 페이지 콘텐츠를 식별할 수 있어야 함.

https://myblog.com/posts/1 보다는 https://myblog.com/posts/how-to-deal-with-seo와 같은 형태

### 페이지에서 정확하고 완성된 메타데이터를 제공

next-seo와 같은 라이브러리를 사용하면 개발 과정에서 큰 부담 없이 메타데이터를 관리하고 구현할 수 있다.

### 이미지를 최적화한다.

Next.js의 내장 이미지 컴포넌트는 구글 크롬 팀과의 협업을 통해 이미지를 더 잘 지원할 수 있도록 만들어졌으며 누적 레이아웃 이동이나 최초 콘텐츠 풀 페인트(FCP)와 같은 SEO 지표도 반영

### 적절한 사이트맵을 만든다.

웹 사이트를 배포했다면 검색엔진에 사이트맵을 제공하여 검색 엔진 측에서 콘텐츠 색인을 더 쉽게 만들도록 해준다. 잘 만든 사이트맵은 검색엔진이 웹 사이트에 대한 색인을 생성할 때 따라갈 수 있는 간결하고 구조화된 경로를 제공하기 때문에 높은 SEO 점수를 얻고자 하는 모든 웹 사이트에서 필수이다.

nextjs-sitemap-generator와 같은 좋은 라이브러리를 사용해서 사이트맵을 만들 수 있다.

### 올바른 HTML 태그 사용

사용자나 검색엔진 봇 모두에게 HTML 태그가 의미가 있도록 적절한 균형을 맞춰야함

# 10.4 성능 다루기

Next.js로 만든 정적 웹 사이트를 Cloudflare나 AWS Cloudfront와 같은 CDN에 배포하면 아마도 기대할 수 있는 최상의 성능을 보여줄 것

반면 서버 사이드 렌더링 애플리케이션을 작고 저렴한 서버에 배포하면 들어오는 요청을 제대로 처리할 수 없을 만큼 나쁜 성능을 보여줄 것이며 결국 서버를 확장할 수밖에 없을 것.

Next.js 10부터 페이지에서 사용할 수 있는 내장 함수인 reportWebVitals를 제공하고 있다. 이 기능은 구글과의 협업을 통해 만들어졌으며 프론트 성능 측정에 중요한 정보를 수집한다.

### 최대 콘텐츠풀 페인드 (largest contentful paint - LCP)

불러오기 성능을 측정, 불러오기는 처음 페이지를 불러온 뒤 2.5초 이내

### 최초 입력 지연(first input delay - FID)

페이지와의 상호 작용이 가능한 상태까지 도달하는 시간 측정. 0.1초 이내

### 누적 레이아웃 이동

시각적 안정성을 나타내는 지표, 아주 큰 사진의 경우 불러오는데 오랜 시간이 걸리기 때문에 다 불러오고 나면 사진을 화면에 표시하면서 레이아웃이 움직이게 되고, 이로 인해 사용자는 보고 있던 곳이 어딘지 잊어버리게 됨. 사진 뿐만 아니라 광고 배너나 위젯 등과 같은 다양한 요소들도 페이지의 레이아웃을 움직이게 만들 수 있다.

- vercel 분석 대시보드

<img width="958" alt="image" src="https://github.com/Hayeong8957/NextJS_BookStudy/assets/70371342/c10a3ec3-3785-4129-ae17-0b19947c44e9">

전체 웹 사이트의 평균 데이터를 보여줌. CLS와 FID는 상당히 높은 반면 FCP와 LCP는 여전히 개선할 필요가 있음

- vercel에서 서비스할 계획이 없다면 \_app.js 페이지에서 reportWebVitals 함수를 구현해서 이러한 성능 지표 데이터를 수집할 수 있다.

```jsx
export const reportWebVitals = (metrics) => console.log(metrics);

export default function MyApp({ Component, pageProps }) {
  return <Component {...pageProps} />;
}
```

<img width="956" alt="image" src="https://github.com/Hayeong8957/NextJS_BookStudy/assets/70371342/297296f0-89e0-480a-9a30-a3f6727829fe">

이런 성능 지표 데이터를 Google Analytics나 Plausible과 같은 외부 서비스로 보내서 의미있는 정보를 얻을 수도 있다.

```jsx
export const reportWebVitals = (metrics) => sendToGoogleAnalytics(metric);

export default function MyApp({ Component, pageProps }) {
  return <Component {...pageProps} />;
}
```
